name: Build and Deploy Orion Website

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Option 1: If it's a .NET Framework 4.8 application with solution file
      - name: Setup MSBuild (if needed)
        uses: microsoft/setup-msbuild@v1.1
        if: hashFiles('**/*.sln') != ''
      
      - name: Setup NuGet (if needed)
        uses: NuGet/setup-nuget@v1.2.0
        if: hashFiles('**/*.sln') != ''
      
      - name: Restore NuGet packages (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh
      
      - name: Build solution (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh
      
      # Option 2: If it's just static files or simpler web application
      - name: Package website content
        run: |
          # Create a deployment package for the website
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            # If we didn't build a .NET app above, package directly
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            # Get website files but exclude database scripts, github workflow files, and the published directory itself
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            # Create published directory
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            
            # Create a zip package
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            # Clean up temp directory
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh
      
      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Check for SQL scripts
        id: check-scripts
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            echo "has_scripts=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "has_scripts=false" >> $env:GITHUB_OUTPUT
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
      
      # Get Azure AD token for SQL authentication
      - name: Get Access Token for Azure SQL
        if: steps.check-scripts.outputs.has_scripts == 'true'
        id: get-token
        run: |
          try {
            $token = az account get-access-token --resource https://database.windows.net/ | ConvertFrom-Json
            
            # Mask the token to prevent exposure in logs
            echo "::add-mask::$($token.accessToken)"
            
            # Verify token was retrieved (length only, for security)
            if ($token.accessToken) {
              $tokenLength = $token.accessToken.Length
              Write-Host "Successfully obtained SQL access token (Length: $tokenLength characters)"
              
              # Set the token as an environment variable
              echo "token_available=true" >> $env:GITHUB_OUTPUT
              echo "SQL_ACCESS_TOKEN=$($token.accessToken)" >> $env:GITHUB_ENV
            } else {
              Write-Warning "Token was retrieved but appears to be empty"
              echo "token_available=false" >> $env:GITHUB_OUTPUT
            }
          } catch {
            Write-Warning "Unable to get access token for SQL: $_"
            echo "token_available=false" >> $env:GITHUB_OUTPUT
            Write-Host "Will fall back to SQL authentication if available"
          }
        shell: pwsh
      
      # Install sqlcmd if scripts need to be executed (ensuring latest version)
      - name: Install sqlcmd utility
        if: steps.check-scripts.outputs.has_scripts == 'true'
        run: |
          Write-Host "Installing sqlcmd utility..."
          
          # Download the latest SQL command line tools
          Invoke-WebRequest -Uri "https://aka.ms/mssql-tools-windows" -OutFile "SQLCMD.msi"
          
          # Install with logging
          $installProcess = Start-Process -FilePath "msiexec.exe" -ArgumentList "/i SQLCMD.msi /quiet /qn /log sqlcmdinstall.log" -Wait -PassThru
          
          if ($installProcess.ExitCode -ne 0) {
            Write-Error "Failed to install sqlcmd. Exit code: $($installProcess.ExitCode)"
            if (Test-Path "sqlcmdinstall.log") {
              Write-Host "Installation log:"
              Get-Content "sqlcmdinstall.log" | Select-Object -Last 20
            }
            exit 1
          }
          
          # Add to PATH
          $env:Path = "$env:Path;C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn"
          Write-Host "Updated PATH: $env:Path"
          
          # Verify installation
          $maxRetries = 3
          $retryCount = 0
          $success = $false
          
          while (-not $success -and $retryCount -lt $maxRetries) {
            try {
              if (Get-Command sqlcmd -ErrorAction Stop) {
                # Show sqlcmd version to verify it's correctly installed and supports -AccessToken
                $versionInfo = & sqlcmd -?
                Write-Host "sqlcmd is installed and available."
                Write-Host "Version info: $versionInfo"
                $success = $true
              }
            } catch {
              $retryCount++
              Write-Warning "Attempt $retryCount of ${maxRetries}: sqlcmd not found yet. Waiting 10 seconds..."
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "sqlcmd was not installed successfully after $maxRetries attempts."
            exit 1
          }
        shell: pwsh
      
      # Primary SQL Script Execution Method: Using Azure CLI
      - name: Deploy SQL Scripts Using Azure CLI
        if: steps.check-scripts.outputs.has_scripts == 'true'
        run: |
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order..."
            $hasErrors = $false
            
            foreach ($script in $scriptFiles) {
              Write-Host "`nExecuting: $($script.Name)"
              
              # Using Azure CLI to execute scripts - this can bypass connection issues
              try {
                # Get script content and truncate for log
                $scriptContent = Get-Content -Path $script.FullName -Raw
                $truncatedContent = if ($scriptContent.Length -gt 200) { $scriptContent.Substring(0, 200) + "..." } else { $scriptContent }
                Write-Host "Script content preview: $truncatedContent"
                
                # Execute script using Azure CLI with the correct command
                Write-Host "Executing SQL script via Azure CLI..."
                az sql db run-query --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name ${{ env.SQL_DATABASE_NAME }} --file "$($script.FullName)" --query-timeout 30
                
                Write-Host "SQL script execution successful via Azure CLI"
              }
              catch {
                $errorMessage = $_.Exception.Message
                
                if ($errorMessage -match "Violation of PRIMARY KEY constraint" -or 
                    $errorMessage -match "Cannot insert duplicate key") {
                  Write-Host "Duplicate key detected - treating as success"
                } else {
                  Write-Warning "Error executing SQL script via Azure CLI: $errorMessage"
                  Write-Host "Attempting alternative execution methods..."
                  
                  # Try executing with token-based authentication
                  if ($env:SQL_ACCESS_TOKEN) {
                    try {
                      Write-Host "Attempting token-based authentication with sqlcmd..."
                      & sqlcmd -S "${{ env.SQL_SERVER_NAME }}.database.windows.net" -d "${{ env.SQL_DATABASE_NAME }}" -G -AccessToken "$env:SQL_ACCESS_TOKEN" -i "$($script.FullName)"
                      
                      if ($LASTEXITCODE -eq 0) {
                        Write-Host "SQL script execution successful via token-based authentication"
                      } else {
                        throw "sqlcmd exited with code $LASTEXITCODE"
                      }
                    }
                    catch {
                      Write-Warning "Error executing SQL script via token-based authentication: $_"
                      Write-Host "Continuing despite errors - this is expected if objects already exist"
                    }
                  } else {
                    Write-Warning "No SQL access token available. Continuing with standard execution."
                    Write-Host "Continuing despite errors - this is expected if objects already exist"
                  }
                }
              }
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
        
      # Fallback Method: Using SQL Server PowerShell Module
      - name: Prepare SQL Server PowerShell Module (Fallback)
        if: steps.check-scripts.outputs.has_scripts == 'true' && failure()
        run: |
          Write-Host "Preparing SQL Server PowerShell module as fallback..."
          # Check if we need to install the module or if we can use existing cmdlets
          if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
            try {
              Install-Module -Name SqlServer -Force -Scope CurrentUser -SkipPublisherCheck -AllowClobber
            } catch {
              Write-Host "Installation failed, but cmdlets may still be available: $_"
            }
          } else {
            Write-Host "Invoke-Sqlcmd is already available. Using existing cmdlets."
          }
          
          # Verify Invoke-Sqlcmd is available
          if (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue) {
            Write-Host "Invoke-Sqlcmd cmdlet is available and ready to use."
          } else {
            Write-Error "Invoke-Sqlcmd cmdlet is not available. SQL script execution will fail."
            exit 1
          }
        shell: pwsh
        
      # Fallback SQL Script Execution Method: Using PowerShell
      - name: Deploy SQL Scripts Using PowerShell (Fallback)
        if: steps.check-scripts.outputs.has_scripts == 'true' && failure()
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
          SQL_PASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}
        run: |
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order using fallback method..."
            $hasErrors = $false
            
            # Define connection parameters - use the fully qualified server name
            $serverName = "${{ env.SQL_SERVER_NAME }}.database.windows.net"
            $databaseName = "${{ env.SQL_DATABASE_NAME }}"
            
            # Verify SQL credentials are available
            if ([string]::IsNullOrEmpty($env:SQL_USERNAME) -or [string]::IsNullOrEmpty($env:SQL_PASSWORD)) {
              Write-Error "SQL authentication credentials are not available. Please set AZURE_SQL_USERNAME and AZURE_SQL_PASSWORD secrets."
              exit 1
            }
            
            # Build a connection string instead of using separate parameters
            $connectionString = "Server=$serverName;Database=$databaseName;User ID=$($env:SQL_USERNAME);Password=$($env:SQL_PASSWORD);Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
            
            Write-Host "Using server: $serverName"
            Write-Host "Using database: $databaseName"
            Write-Host "Using username: $($env:SQL_USERNAME)"
            
            foreach ($script in $scriptFiles) {
              Write-Host "Executing: $($script.Name)"
              
              # Execute SQL using Invoke-Sqlcmd with connection string
              $maxRetries = 3
              $retryCount = 0
              $success = $false
              
              while (-not $success -and $retryCount -lt $maxRetries) {
                try {
                  # Read the script content directly
                  $sqlContent = Get-Content -Path "$($script.FullName)" -Raw
                  
                  # Execute the script using connection string
                  Invoke-Sqlcmd -ConnectionString $connectionString -Query $sqlContent -QueryTimeout 300 -ErrorAction Stop
                  
                  $success = $true
                  Write-Host "SQL script executed successfully"
                }
                catch {
                  $retryCount++
                  Write-Warning "Attempt $retryCount of $maxRetries failed: $_"
                  if ($retryCount -lt $maxRetries) {
                    Write-Host "Waiting 10 seconds before retry..."
                    Start-Sleep -Seconds 10
                  }
                }
              }
              
              if (-not $success) {
                Write-Error "Failed to execute SQL script after $maxRetries attempts: $($script.Name)"
                $hasErrors = $true
                break
              }
            }
            
            if ($hasErrors) {
              exit 1
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    if: github.event_name != 'pull_request'
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Verify staging slot exists
        id: check-staging-slot
        run: |
          try {
            $slot = az webapp deployment slot list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --query "[?name=='staging']" -o json | ConvertFrom-Json
            
            if ($slot -and $slot.Length -gt 0) {
              Write-Host "Staging slot exists."
              echo "slot_exists=true" >> $env:GITHUB_OUTPUT
            } else {
              Write-Host "Staging slot does not exist. Will create it."
              echo "slot_exists=false" >> $env:GITHUB_OUTPUT
            }
          } catch {
            Write-Warning "Error checking if staging slot exists: $_"
            echo "slot_exists=false" >> $env:GITHUB_OUTPUT
            Write-Host "Will attempt to create staging slot if needed."
          }
        shell: pwsh
        
      - name: Create staging slot if needed
        if: steps.check-staging-slot.outputs.slot_exists != 'true'
        run: |
          try {
            Write-Host "Creating staging slot..."
            az webapp deployment slot create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging
            Write-Host "Staging slot created successfully."
          } catch {
            Write-Warning "Error creating staging slot: $_"
            Write-Host "Will attempt to deploy directly to staging slot in case it was created but the command failed."
          }
        shell: pwsh
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/**/*.zip
      
      - name: Wait for deployment to stabilize
        run: |
          Start-Sleep -Seconds 30
          Write-Host "Waiting for deployment to stabilize..."
        shell: pwsh
      
      - name: Validate staging deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Staging validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    if: github.event_name != 'pull_request'
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          Write-Host "Swapping staging slot to production..."
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Production deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Production validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh
        
      - name: Save deployment record for rollback purposes
        run: |
          $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
          $deploymentRecord = @{
            "timestamp" = $timestamp
            "commitId" = "${{ github.sha }}"
            "workflow" = "${{ github.workflow }}"
            "runId" = "${{ github.run_id }}"
          }
          
          $deploymentJson = $deploymentRecord | ConvertTo-Json
          Write-Host "Saving deployment record: $deploymentJson"
          
          # In a real implementation, you might save this to a Blob Storage or other persistent location
          # for automated rollback capability
        shell: pwsh
