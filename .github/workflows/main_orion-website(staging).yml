name: Build and Deploy Orion Website

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'
  # Note: We'll use AZURE_SQL_USERNAME from secrets for SqlDeploymentUser

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Option 1: If it's a .NET Framework 4.8 application with solution file
      - name: Setup MSBuild (if needed)
        uses: microsoft/setup-msbuild@v1.1
        if: hashFiles('**/*.sln') != ''
      
      - name: Setup NuGet (if needed)
        uses: NuGet/setup-nuget@v1.2.0
        if: hashFiles('**/*.sln') != ''
      
      - name: Restore NuGet packages (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh
      
      - name: Build solution (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh
      
      # Option 2: If it's just static files or simpler web application
      - name: Package website content
        run: |
          # Create a deployment package for the website
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            # If we didn't build a .NET app above, package directly
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            # Get website files but exclude database scripts, github workflow files, and the published directory itself
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            # Create published directory
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            
            # Create a zip package
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            # Clean up temp directory
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh
      
      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Check for SQL scripts
        id: check-scripts
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            echo "has_scripts=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "has_scripts=false" >> $env:GITHUB_OUTPUT
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
      
      # Examine and potentially modify SQL scripts to handle variables
      - name: Preprocess SQL scripts
        if: steps.check-scripts.outputs.has_scripts == 'true'
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
        run: |
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          foreach ($script in $scriptFiles) {
            $scriptContent = Get-Content -Path $script.FullName -Raw
            
            # Check if the script contains variables that need substitution
            if ($scriptContent -match '\$\(SqlDeploymentUser\)') {
              Write-Host "Script $($script.Name) contains SqlDeploymentUser variable - replacing with $env:SQL_USERNAME"
              
              # Replace the variable with the actual username
              $updatedContent = $scriptContent.Replace('$(SqlDeploymentUser)', $env:SQL_USERNAME)
              
              # Write back the modified script
              Set-Content -Path $script.FullName -Value $updatedContent
              
              Write-Host "Updated script content with username substitution"
            }
            
            # Check for any other variables that might need substitution
            if ($scriptContent -match '\$\([^\)]+\)') {
              Write-Host "WARNING: Script $($script.Name) may contain other variables that need substitution"
              # List all variables found for debugging
              $matches = [regex]::Matches($scriptContent, '\$\(([^\)]+)\)')
              foreach ($match in $matches) {
                Write-Host "  Found variable: $($match.Groups[1].Value)"
              }
            }
          }
        shell: pwsh
      
      # First try: Use Azure CLI directly
      - name: Deploy SQL Scripts Using Azure CLI
        if: steps.check-scripts.outputs.has_scripts == 'true'
        run: |
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order..."
            $hasErrors = $false
            
            foreach ($script in $scriptFiles) {
              Write-Host "`nExecuting: $($script.Name)"
              
              # Using Azure CLI to execute scripts
              try {
                # Execute script using Azure CLI with the correct command
                Write-Host "Executing SQL script via Azure CLI..."
                az sql db run-query --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name ${{ env.SQL_DATABASE_NAME }} --file "$($script.FullName)" --query-timeout 30
                
                Write-Host "SQL script execution successful via Azure CLI"
              }
              catch {
                $errorMessage = $_.Exception.Message
                Write-Warning "Error executing script via Azure CLI: $errorMessage"
                Write-Host "Will attempt alternative execution method"
                $hasErrors = $true
              }
            }
            
            # If there were errors with Azure CLI, we'll try the SqlServer module as a fallback
            if ($hasErrors) {
              Write-Host "Errors occurred with Azure CLI. Attempting alternative execution method."
              throw "Azure CLI execution had errors - moving to fallback method"
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
        continue-on-error: true
        id: azure-cli-deploy
      
      # Install SqlServer PowerShell module as a fallback
      - name: Install SQL Server PowerShell Module
        if: steps.check-scripts.outputs.has_scripts == 'true' && steps.azure-cli-deploy.outcome != 'success'
        run: |
          Write-Host "Installing SqlServer PowerShell module..."
          Install-Module -Name SqlServer -Force -Scope CurrentUser -SkipPublisherCheck
          Import-Module SqlServer
          Write-Host "SqlServer module installed successfully."
        shell: pwsh
      
      # Fallback method: Use PowerShell's Invoke-Sqlcmd with variable handling
      - name: Deploy SQL Scripts Using PowerShell with Variable Handling
        if: steps.check-scripts.outputs.has_scripts == 'true' && steps.azure-cli-deploy.outcome != 'success'
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
          SQL_PASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}
        run: |
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order using fallback method..."
            $hasErrors = $false
            
            # Define connection parameters - use the fully qualified server name
            $serverName = "${{ env.SQL_SERVER_NAME }}.database.windows.net"
            $databaseName = "${{ env.SQL_DATABASE_NAME }}"
            
            # Verify SQL credentials are available
            if ([string]::IsNullOrEmpty($env:SQL_USERNAME) -or [string]::IsNullOrEmpty($env:SQL_PASSWORD)) {
              Write-Error "SQL authentication credentials are not available. Please set AZURE_SQL_USERNAME and AZURE_SQL_PASSWORD secrets."
              exit 1
            }
            
            # Build a connection string
            $connectionString = "Server=$serverName;Database=$databaseName;User ID=$($env:SQL_USERNAME);Password=$($env:SQL_PASSWORD);Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
            
            Write-Host "Using server: $serverName"
            Write-Host "Using database: $databaseName"
            Write-Host "Using username: $($env:SQL_USERNAME)"
            
            foreach ($script in $scriptFiles) {
              Write-Host "Executing: $($script.Name)"
              
              # Execute SQL using Invoke-Sqlcmd with connection string
              $maxRetries = 3
              $retryCount = 0
              $success = $false
              
              while (-not $success -and $retryCount -lt $maxRetries) {
                try {
                  # Read the script content directly
                  $sqlContent = Get-Content -Path "$($script.FullName)" -Raw
                  
                  # Define variables that might be used in the script
                  # Important: Use SQL_USERNAME as the value for SqlDeploymentUser
                  $scriptVariables = @{
                    "SqlDeploymentUser" = "$env:SQL_USERNAME"
                    # Add any other variables that your scripts might use
                  }
                  
                  # Execute the script using connection string and variable substitution
                  Write-Host "Executing with variables: SqlDeploymentUser=$($env:SQL_USERNAME)"
                  
                  Invoke-Sqlcmd -ConnectionString $connectionString -Query $sqlContent -QueryTimeout 300 -ErrorAction Stop -Variable $scriptVariables
                  
                  $success = $true
                  Write-Host "SQL script executed successfully"
                }
                catch {
                  $retryCount++
                  Write-Warning "Attempt $retryCount of $maxRetries failed: $_"
                  
                  if ($_.Exception.Message -match "Cannot find the object" -or 
                      $_.Exception.Message -match "already exists" -or
                      $_.Exception.Message -match "Violation of PRIMARY KEY constraint") {
                    # These are typically non-fatal errors for idempotent scripts
                    Write-Host "Error appears to be related to object already existing - treating as success"
                    $success = $true
                  }
                  elseif ($retryCount -lt $maxRetries) {
                    Write-Host "Waiting 10 seconds before retry..."
                    Start-Sleep -Seconds 10
                  }
                }
              }
              
              if (-not $success) {
                Write-Error "Failed to execute SQL script after $maxRetries attempts: $($script.Name)"
                $hasErrors = $true
                break
              }
            }
            
            if ($hasErrors) {
              exit 1
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    if: github.event_name != 'pull_request'
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/**/*.zip
      
      - name: Wait for deployment to stabilize
        run: |
          Start-Sleep -Seconds 30
          Write-Host "Waiting for deployment to stabilize..."
        shell: pwsh
      
      - name: Validate staging deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Staging validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    if: github.event_name != 'pull_request'
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          Write-Host "Swapping staging slot to production..."
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Production deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Production validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh
