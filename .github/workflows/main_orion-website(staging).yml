name: Deploy Orion Website to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  AZURE_KEYVAULT_NAME: 'orion-website-kv'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Cache NuGet Packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.config') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Setup MSBuild and NuGet
        uses: microsoft/setup-msbuild@v1.1

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v1.2.0

      - name: Restore NuGet Packages
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh

      - name: Build Solution
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh

      - name: Package Website
        run: |
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh

      - name: Upload artifact for deployment
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      # Allow GitHub Actions IP in Azure SQL Firewall
      - name: Configure SQL firewall for GitHub Actions
        run: |
          # Get GitHub Actions IP address
          $currentIP = (Invoke-WebRequest -Uri https://api.ipify.org).Content
          Write-Host "Current GitHub Actions IP: $currentIP"
          
          # Add firewall rule to allow this IP
          Write-Host "Adding firewall rule for GitHub Actions IP..."
          az sql server firewall-rule create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name "GitHubActions-Temp" --start-ip-address $currentIP --end-ip-address $currentIP
          
          Write-Host "Firewall rule added successfully."
        shell: pwsh
      
      - name: Install SqlServer module
        run: |
          Install-Module -Name SqlServer -Force -Scope CurrentUser -SkipPublisherCheck -AllowClobber
        shell: pwsh
      
      - name: Deploy SQL Scripts
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
          SQL_PASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}
        run: |
          # Function with retry logic for SQL connection
          function Invoke-SqlCmdWithRetry {
              param (
                  [string]$ServerName,
                  [string]$DatabaseName,
                  [string]$Username,
                  [string]$Password,
                  [string]$ScriptPath,
                  [int]$MaxRetries = 5,
                  [int]$RetryDelaySeconds = 30,
                  [int]$CommandTimeout = 600
              )
              
              $retryCount = 0
              $success = $false
              
              while (-not $success -and $retryCount -lt $MaxRetries) {
                  try {
                      Write-Host "Attempt $($retryCount + 1) of $MaxRetries to execute SQL script: $ScriptPath"
                      
                      # Build connection string with longer timeout
                      $connectionString = "Server=$ServerName;Database=$DatabaseName;User ID=$Username;Password=$Password;Encrypt=True;TrustServerCertificate=False;Connection Timeout=60;"
                      
                      # Use connection string instead of individual parameters for better control
                      Invoke-Sqlcmd -ConnectionString $connectionString -InputFile $ScriptPath -QueryTimeout $CommandTimeout -ErrorAction Stop
                      
                      $success = $true
                      Write-Host "SQL script executed successfully!"
                  }
                  catch {
                      $retryCount++
                      $errorMsg = $_.Exception.Message
                      
                      if ($errorMsg -match "Violation of PRIMARY KEY constraint" -or 
                          $errorMsg -match "Cannot insert duplicate key") {
                          Write-Host "Duplicate key detected - treating as success"
                          $success = $true
                      }
                      elseif ($retryCount -lt $MaxRetries) {
                          Write-Warning "SQL connection failed: $errorMsg"
                          Write-Host "Waiting $RetryDelaySeconds seconds before retry..."
                          Start-Sleep -Seconds $RetryDelaySeconds
                      }
                      else {
                          Write-Error "Failed to execute SQL script after $MaxRetries attempts: $errorMsg"
                          return $false
                      }
                  }
              }
              
              return $success
          }
          
          # Check for SQL scripts
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
              $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
              $serverName = "${{ env.SQL_SERVER_NAME }}.database.windows.net"
              $databaseName = "${{ env.SQL_DATABASE_NAME }}"
              
              # Diagnostic info
              Write-Host "Server: $serverName"
              Write-Host "Database: $databaseName"
              Write-Host "Username: $env:SQL_USERNAME"
              Write-Host "Found $($scriptFiles.Count) SQL scripts to execute"
              
              $hasErrors = $false
              
              foreach ($script in $scriptFiles) {
                  Write-Host "Processing: $($script.Name)"
                  
                  $result = Invoke-SqlCmdWithRetry -ServerName $serverName -DatabaseName $databaseName -Username $env:SQL_USERNAME -Password $env:SQL_PASSWORD -ScriptPath $script.FullName
                  
                  if (-not $result) {
                      $hasErrors = $true
                      break
                  }
              }
              
              if ($hasErrors) {
                  exit 1
              }
          } else {
              Write-Host "No SQL scripts found. Skipping database deployment."
          }
        shell: pwsh
      
      # Clean up the temporary firewall rule
      - name: Remove temporary firewall rule
        if: always()
        run: |
          Write-Host "Removing temporary firewall rule..."
          az sql server firewall-rule delete --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name "GitHubActions-Temp" --yes
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/**/*.zip
      
      - name: Validate staging deployment
        run: |
          Start-Sleep -Seconds 60
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing
              if ($response.StatusCode -eq 200) {
                Write-Host "Staging deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $($response.StatusCode). Retrying..."
                $retryCount++
                Start-Sleep -Seconds 15
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 15
            }
          }
          
          if (-not $success) {
            $appState = az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "state" -o tsv
            if ($appState -eq "Running") {
              Write-Host "App is running but validation requests failed. Proceeding with caution."
            } else {
              Write-Error "Staging validation failed"
              exit 1
            }
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          Start-Sleep -Seconds 60
          $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing -MaximumRetryCount 5 -RetryIntervalSec 15
          Write-Host "Production deployment validated - Status code: $($response.StatusCode)"
        shell: pwsh
