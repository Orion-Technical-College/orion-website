name: Build and Deploy Orion Website

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Option 1: If it's a .NET Framework 4.8 application with solution file
      - name: Setup MSBuild (if needed)
        uses: microsoft/setup-msbuild@v1.1
        if: hashFiles('**/*.sln') != ''
      
      - name: Setup NuGet (if needed)
        uses: NuGet/setup-nuget@v1.2.0
        if: hashFiles('**/*.sln') != ''
      
      - name: Restore NuGet packages (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh
      
      - name: Build solution (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh
      
      # Option 2: If it's just static files or simpler web application
      - name: Package website content
        run: |
          # Create a deployment package for the website
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            # If we didn't build a .NET app above, package directly
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            # Get website files but exclude database scripts, github workflow files, and the published directory itself
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            # Create published directory
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            
            # Create a zip package
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            # Clean up temp directory
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh
      
      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Check for SQL scripts
        id: check-scripts
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            echo "has_scripts=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "has_scripts=false" >> $env:GITHUB_OUTPUT
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
      
      - name: Install SQL Server PowerShell Module
        if: steps.check-scripts.outputs.has_scripts == 'true'
        run: |
          Write-Host "Installing SqlServer PowerShell module..."
          Install-Module -Name SqlServer -Force -Scope CurrentUser -SkipPublisherCheck
          Import-Module SqlServer
          Write-Host "SqlServer module installed successfully."
        shell: pwsh
        
      - name: Deploy SQL Scripts Using PowerShell
        if: steps.check-scripts.outputs.has_scripts == 'true'
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
          SQL_PASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}
        run: |
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order..."
            $hasErrors = $false
            
            # Define connection parameters
            $serverName = "${{ env.SQL_SERVER_NAME }}.database.windows.net"
            $databaseName = "${{ env.SQL_DATABASE_NAME }}"
            
            # Verify SQL credentials are available
            if ([string]::IsNullOrEmpty($env:SQL_USERNAME) -or [string]::IsNullOrEmpty($env:SQL_PASSWORD)) {
              Write-Error "SQL authentication credentials are not available. Please set AZURE_SQL_USERNAME and AZURE_SQL_PASSWORD secrets."
              exit 1
            }
            
            foreach ($script in $scriptFiles) {
              Write-Host "Executing: $($script.Name)"
              
              # Execute SQL using Invoke-Sqlcmd
              $maxRetries = 3
              $retryCount = 0
              $success = $false
              
              while (-not $success -and $retryCount -lt $maxRetries) {
                try {
                  # Execute the script using PowerShell's Invoke-Sqlcmd
                  Invoke-Sqlcmd -ServerInstance $serverName `
                                -Database $databaseName `
                                -Username $env:SQL_USERNAME `
                                -Password $env:SQL_PASSWORD `
                                -InputFile "$($script.FullName)" `
                                -QueryTimeout 300 `
                                -ErrorAction Stop
                  
                  $success = $true
                  Write-Host "SQL script executed successfully"
                }
                catch {
                  $retryCount++
                  Write-Warning "Attempt $retryCount of $maxRetries failed: $_"
                  if ($retryCount -lt $maxRetries) {
                    Write-Host "Waiting 10 seconds before retry..."
                    Start-Sleep -Seconds 10
                  }
                }
              }
              
              if (-not $success) {
                Write-Error "Failed to execute SQL script after $maxRetries attempts: $($script.Name)"
                $hasErrors = $true
                break
              }
            }
            
            if ($hasErrors) {
              exit 1
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder."
          }
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    if: github.event_name != 'pull_request'
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/**/*.zip
      
      - name: Wait for deployment to stabilize
        run: |
          Start-Sleep -Seconds 30
          Write-Host "Waiting for deployment to stabilize..."
        shell: pwsh
      
      - name: Validate staging deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Staging validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    if: github.event_name != 'pull_request'
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          Write-Host "Swapping staging slot to production..."
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Production deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Production validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh
