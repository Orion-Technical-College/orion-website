name: Build and Deploy Orion Website

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  SQL_SERVER_NAME: 'orionweb-sqlserver.database.windows.net'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Option 1: If it's a .NET Framework 4.8 application with solution file
      - name: Setup MSBuild (if needed)
        uses: microsoft/setup-msbuild@v1.1
        if: hashFiles('**/*.sln') != ''
      
      - name: Setup NuGet (if needed)
        uses: NuGet/setup-nuget@v1.2.0
        if: hashFiles('**/*.sln') != ''
      
      - name: Restore NuGet packages (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh
      
      - name: Build solution (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh
      
      # Option 2: If it's just static files or simpler web application
      - name: Package website content
        run: |
          # Create a deployment package for the website
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            # If we didn't build a .NET app above, package directly
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            # Get website files but exclude database scripts, github workflow files, and the published directory itself
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            # Create published directory
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            
            # Create a zip package
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            # Clean up temp directory
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh
      
      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Check for SQL scripts
        id: check-scripts
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            echo "has_scripts=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "has_scripts=false" >> $env:GITHUB_OUTPUT
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
      
      # Get Azure AD token for SQL authentication
      - name: Get Access Token for Azure SQL
        if: steps.check-scripts.outputs.has_scripts == 'true'
        id: get-token
        run: |
          try {
            $token = az account get-access-token --resource https://database.windows.net/ | ConvertFrom-Json
            echo "::add-mask::$($token.accessToken)"
            echo "token_available=true" >> $env:GITHUB_OUTPUT
            echo "SQL_ACCESS_TOKEN=$($token.accessToken)" >> $env:GITHUB_ENV
            Write-Host "Successfully obtained SQL access token"
          } catch {
            Write-Warning "Unable to get access token for SQL: $_"
            echo "token_available=false" >> $env:GITHUB_OUTPUT
            Write-Host "Will fall back to SQL authentication if available"
          }
        shell: pwsh
      
      # Install sqlcmd if scripts need to be executed
      - name: Install sqlcmd utility
        if: steps.check-scripts.outputs.has_scripts == 'true'
        run: |
          Write-Host "Installing sqlcmd utility..."
          Invoke-WebRequest -Uri "https://aka.ms/mssql-tools-windows" -OutFile "SQLCMD.msi"
          Start-Process -FilePath "msiexec.exe" -ArgumentList "/i SQLCMD.msi /quiet /qn" -Wait
          
          # Add to PATH
          $env:Path = "$env:Path;C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn"
          
          # Verify installation
          $maxRetries = 3
          $retryCount = 0
          $success = $false
          
          while (-not $success -and $retryCount -lt $maxRetries) {
            try {
              if (Get-Command sqlcmd -ErrorAction Stop) {
                Write-Host "sqlcmd is installed and available."
                $success = $true
              }
            } catch {
              $retryCount++
              Write-Warning "Attempt $retryCount of ${maxRetries}: sqlcmd not found yet. Waiting 10 seconds..."
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "sqlcmd was not installed successfully after $maxRetries attempts."
            exit 1
          }
        shell: pwsh
      
      # Execute SQL scripts - Preferring token-based authentication
      - name: Deploy SQL Scripts with Token Auth
        if: steps.check-scripts.outputs.has_scripts == 'true' && steps.get-token.outputs.token_available == 'true'
        run: |
          # Function to execute SQL with retry logic
          function Invoke-SqlCmdWithRetry {
              param (
                  [string]$ServerName,
                  [string]$DatabaseName,
                  [string]$ScriptPath,
                  [int]$MaxRetries = 3,
                  [int]$RetryDelaySeconds = 10
              )
              
              $retryCount = 0
              $success = $false
              
              while (-not $success -and $retryCount -lt $MaxRetries) {
                  try {
                      Write-Host "Executing SQL script: $ScriptPath"
                      
                      # Use Azure AD token authentication with proper token formatting
                      # The space after -AccessToken is critical
                      & sqlcmd -S $ServerName -d $DatabaseName -G -AccessToken $env:SQL_ACCESS_TOKEN -i $ScriptPath
                      
                      if ($LASTEXITCODE -eq 0) {
                          $success = $true
                          Write-Host "SQL script executed successfully"
                      } else {
                          throw "sqlcmd exited with code $LASTEXITCODE"
                      }
                  }
                  catch {
                      $retryCount++
                      Write-Warning "Attempt $retryCount of $MaxRetries failed: $_"
                      if ($retryCount -lt $MaxRetries) {
                          Write-Host "Waiting $RetryDelaySeconds seconds before retry..."
                          Start-Sleep -Seconds $RetryDelaySeconds
                      }
                  }
              }
              
              if (-not $success) {
                  Write-Error "Failed to execute SQL script after $MaxRetries attempts"
                  return $false
              }
              
              return $true
          }
          
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order..."
            $hasErrors = $false
            
            foreach ($script in $scriptFiles) {
              Write-Host "Executing: $($script.Name)"
              
              $result = Invoke-SqlCmdWithRetry -ServerName "${{ env.SQL_SERVER_NAME }}" -DatabaseName "${{ env.SQL_DATABASE_NAME }}" -ScriptPath "$($script.FullName)"
              
              if (-not $result) {
                Write-Error "Error executing SQL script: $($script.Name)"
                $hasErrors = $true
                break
              }
            }
            
            if ($hasErrors) {
              exit 1
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder."
          }
        shell: pwsh
      
      # Fallback to SQL authentication if token is not available
      - name: Deploy SQL Scripts with SQL Auth
        if: steps.check-scripts.outputs.has_scripts == 'true' && steps.get-token.outputs.token_available != 'true'
        run: |
          # Verify SQL credentials are available
          if ([string]::IsNullOrEmpty("${{ secrets.AZURE_SQL_USERNAME }}") -or [string]::IsNullOrEmpty("${{ secrets.AZURE_SQL_PASSWORD }}")) {
            Write-Error "SQL authentication credentials are not available and token authentication failed."
            exit 1
          }
          
          # Function to execute SQL with retry logic
          function Invoke-SqlCmdWithRetry {
              param (
                  [string]$ServerName,
                  [string]$DatabaseName,
                  [string]$ScriptPath,
                  [string]$Username,
                  [string]$Password,
                  [int]$MaxRetries = 3,
                  [int]$RetryDelaySeconds = 10
              )
              
              $retryCount = 0
              $success = $false
              
              while (-not $success -and $retryCount -lt $MaxRetries) {
                  try {
                      Write-Host "Executing SQL script: $ScriptPath"
                      
                      # Use SQL authentication
                      & sqlcmd -S $ServerName -d $DatabaseName -U $Username -P $Password -i $ScriptPath
                      
                      if ($LASTEXITCODE -eq 0) {
                          $success = $true
                          Write-Host "SQL script executed successfully"
                      } else {
                          throw "sqlcmd exited with code $LASTEXITCODE"
                      }
                  }
                  catch {
                      $retryCount++
                      Write-Warning "Attempt $retryCount of $MaxRetries failed: $_"
                      if ($retryCount -lt $MaxRetries) {
                          Write-Host "Waiting $RetryDelaySeconds seconds before retry..."
                          Start-Sleep -Seconds $RetryDelaySeconds
                      }
                  }
              }
              
              if (-not $success) {
                  Write-Error "Failed to execute SQL script after $MaxRetries attempts"
                  return $false
              }
              
              return $true
          }
          
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order..."
            $hasErrors = $false
            
            foreach ($script in $scriptFiles) {
              Write-Host "Executing: $($script.Name)"
              
              $result = Invoke-SqlCmdWithRetry -ServerName "${{ env.SQL_SERVER_NAME }}" -DatabaseName "${{ env.SQL_DATABASE_NAME }}" -ScriptPath "$($script.FullName)" -Username "${{ secrets.AZURE_SQL_USERNAME }}" -Password "${{ secrets.AZURE_SQL_PASSWORD }}"
              
              if (-not $result) {
                Write-Error "Error executing SQL script: $($script.Name)"
                $hasErrors = $true
                break
              }
            }
            
            if ($hasErrors) {
              exit 1
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder."
          }
        shell: pwsh
        env:
          SQLCMDPASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    if: github.event_name != 'pull_request'
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/**/*.zip
      
      - name: Wait for deployment to stabilize
        run: |
          Start-Sleep -Seconds 30
          Write-Host "Waiting for deployment to stabilize..."
        shell: pwsh
      
      - name: Validate staging deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Staging validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    if: github.event_name != 'pull_request'
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          Write-Host "Swapping staging slot to production..."
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Production deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Production validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh
