name: Build and Deploy Orion Website

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Option 1: If it's a .NET Framework 4.8 application with solution file
      - name: Setup MSBuild (if needed)
        uses: microsoft/setup-msbuild@v1.1
        if: hashFiles('**/*.sln') != ''
      
      - name: Setup NuGet (if needed)
        uses: NuGet/setup-nuget@v1.2.0
        if: hashFiles('**/*.sln') != ''
      
      - name: Restore NuGet packages (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh
      
      - name: Build solution (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh
      
      # Option 2: If it's just static files or simpler web application
      - name: Package website content
        run: |
          # Create a deployment package for the website
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            # If we didn't build a .NET app above, package directly
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            # Get website files but exclude database scripts, github workflow files, and the published directory itself
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            # Create published directory
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            
            # Create a zip package
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            # Clean up temp directory
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh
      
      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Check for SQL scripts
        id: check-scripts
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            echo "has_scripts=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "has_scripts=false" >> $env:GITHUB_OUTPUT
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
      
      - name: Prepare SQL Server PowerShell Module
        if: steps.check-scripts.outputs.has_scripts == 'true'
        run: |
          Write-Host "Preparing SqlServer PowerShell module..."
          # Check if we need to install the module or if we can use existing cmdlets
          if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
            try {
              Install-Module -Name SqlServer -Force -Scope CurrentUser -SkipPublisherCheck -AllowClobber
            } catch {
              Write-Host "Installation failed, but cmdlets may still be available: $_"
            }
          } else {
            Write-Host "Invoke-Sqlcmd is already available. Using existing cmdlets."
          }
          
          # Verify Invoke-Sqlcmd is available
          if (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue) {
            Write-Host "Invoke-Sqlcmd cmdlet is available and ready to use."
          } else {
            Write-Error "Invoke-Sqlcmd cmdlet is not available. SQL script execution will fail."
            exit 1
          }
        shell: pwsh
        
      - name: Deploy SQL Scripts with Direct Replacements
        if: steps.check-scripts.outputs.has_scripts == 'true'
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
          SQL_PASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}
        run: |
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order..."
            $hasErrors = $false
            
            # Define connection parameters
            $serverName = "${{ env.SQL_SERVER_NAME }}.database.windows.net"
            $databaseName = "${{ env.SQL_DATABASE_NAME }}"
            $connectionString = "Server=$serverName;Database=$databaseName;User ID=$env:SQL_USERNAME;Password=$env:SQL_PASSWORD;Encrypt=True;TrustServerCertificate=False;Connection Timeout=60;"
            
            # Display connection information
            Write-Host "Using server: $serverName"
            Write-Host "Using database: $databaseName"
            Write-Host "Using username: $env:SQL_USERNAME"
            
            foreach ($script in $scriptFiles) {
              Write-Host "Processing: $($script.Name)"
              
              # Read the script content
              $sqlContent = Get-Content -Path "$($script.FullName)" -Raw
              $tempFile = "$($script.FullName).temp"
              
              # Check if script contains SQL variables
              $containsVariables = $sqlContent -match '\$\(SqlDeploymentUser\)' -or $script.Name -eq "Step2-SP.sql" -or $script.Name -eq "Step2-SP-Modified.sql"
              
              if ($containsVariables) {
                Write-Host "Script contains SQL variables - applying direct replacements"
                
                # Create modified content with replacements
                $modifiedContent = $sqlContent
                
                # Replace any variable references
                $modifiedContent = $modifiedContent -replace '\$\(SqlDeploymentUser\)', $env:SQL_USERNAME
                $modifiedContent = $modifiedContent -replace '\$\(CreateDatabaseUser\)', 'true'
                $modifiedContent = $modifiedContent -replace '\$\(CreateDeploymentUserSchema\)', 'true'
                
                # Replace hardcoded user references
                $modifiedContent = $modifiedContent -replace "'nareshki_demo3db'", "'$($env:SQL_USERNAME)'"
                $modifiedContent = $modifiedContent -replace "\[nareshki_demo3db\]", "[$($env:SQL_USERNAME)]"
                $modifiedContent = $modifiedContent -replace "nareshki_demo3db\.", "dbo."
                
                # Write modified content to temp file
                Set-Content -Path $tempFile -Value $modifiedContent
                $fileToExecute = $tempFile
              } else {
                $fileToExecute = $script.FullName
              }
              
              # Execute the script with multiple retries
              $success = $false
              $maxRetries = 3
              $retryCount = 0
              
              while (-not $success -and $retryCount -lt $maxRetries) {
                try {
                  Write-Host "Executing script - Attempt $($retryCount + 1)"
                  Invoke-Sqlcmd -ConnectionString $connectionString -InputFile $fileToExecute -QueryTimeout 300 -ErrorAction Stop
                  $success = $true
                  Write-Host "SQL script executed successfully"
                }
                catch {
                  $retryCount++
                  Write-Warning "Execution attempt $retryCount failed: $_"
                  
                  if ($retryCount -lt $maxRetries) {
                    Write-Host "Waiting 10 seconds before retry..."
                    Start-Sleep -Seconds 10
                  } else if ($containsVariables) {
                    # Last attempt with further modifications for Step2-SP.sql
                    try {
                      Write-Host "Making final attempt with additional modifications..."
                      
                      # Comment out problematic sections
                      $lastAttemptContent = $modifiedContent -replace "EXECUTE AS USER\s*=\s*'[^']+'", "-- EXECUTE AS USER commented out by deployment"
                      $lastAttemptContent = $lastAttemptContent -replace "WITH EXECUTE AS\s*=\s*'[^']+'", "-- WITH EXECUTE AS commented out by deployment"
                      $lastAttemptContent = $lastAttemptContent -replace "CREATE USER.*nareshki_demo3db", "-- CREATE USER commented out by deployment"
                      $lastAttemptContent = $lastAttemptContent -replace "CREATE SCHEMA.*nareshki_demo3db", "-- CREATE SCHEMA commented out by deployment"
                      
                      $finalTempFile = "$($script.FullName).final.temp"
                      Set-Content -Path $finalTempFile -Value $lastAttemptContent
                      
                      Invoke-Sqlcmd -ConnectionString $connectionString -InputFile $finalTempFile -QueryTimeout 300 -ErrorAction Stop
                      $success = $true
                      Write-Host "SQL script executed successfully with additional modifications"
                      
                      # Clean up final temp file
                      if (Test-Path $finalTempFile) {
                        Remove-Item $finalTempFile -Force -ErrorAction SilentlyContinue
                      }
                    }
                    catch {
                      Write-Warning "Final attempt failed: $_"
                    }
                  }
                }
                finally {
                  # Clean up temp file if it exists
                  if ($containsVariables -and (Test-Path $tempFile)) {
                    Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
                  }
                }
              }
              
              if (-not $success) {
                Write-Error "Failed to execute SQL script after all attempts: $($script.Name)"
                $hasErrors = $true
                break
              }
            }
            
            if ($hasErrors) {
              exit 1
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder."
          }
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    if: github.event_name != 'pull_request'
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/**/*.zip
      
      - name: Wait for deployment to stabilize
        run: |
          Start-Sleep -Seconds 30
          Write-Host "Waiting for deployment to stabilize..."
        shell: pwsh
      
      - name: Validate staging deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Staging validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    if: github.event_name != 'pull_request'
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          Write-Host "Swapping staging slot to production..."
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Production deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 10
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 10
            }
          }
          
          if (-not $success) {
            Write-Error "Production validation failed after $maxRetries attempts!"
            exit 1
          }
        shell: pwsh
