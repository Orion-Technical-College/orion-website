name: Deploy Orion Website to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Cache NuGet Packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.config') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1.1

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v1.2.0

      - name: Restore NuGet Packages
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh

      - name: Build Solution
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh

      - name: Package Website
        run: |
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh

      - name: Upload artifact for deployment
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      # Allow Azure services to access SQL
      - name: Configure SQL Server to allow Azure services
        run: |
          Write-Host "Configuring SQL Server to allow Azure services..."
          # Check if rule already exists
          $ruleExists = az sql server firewall-rule show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name "AllowAllAzureServices" --query "name" -o tsv 2>$null
          
          if (-not $ruleExists) {
            az sql server firewall-rule create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name "AllowAllAzureServices" --start-ip-address "0.0.0.0" --end-ip-address "0.0.0.0"
            Write-Host "Firewall rule added for Azure services"
          } else {
            Write-Host "Firewall rule for Azure services already exists"
          }
        shell: pwsh
      
      # Add GitHub Actions IP to firewall
      - name: Add GitHub Actions IP to SQL Firewall
        run: |
          # Get GitHub Actions IP address
          $currentIP = (Invoke-WebRequest -Uri https://api.ipify.org).Content
          Write-Host "Current GitHub Actions IP: $currentIP"
          
          # Check if rule already exists
          $ruleName = "GitHubActions-Temp"
          $ruleExists = az sql server firewall-rule show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name $ruleName --query "name" -o tsv 2>$null
          
          if (-not $ruleExists) {
            # Add firewall rule
            Write-Host "Adding firewall rule for GitHub Actions IP..."
            az sql server firewall-rule create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name $ruleName --start-ip-address $currentIP --end-ip-address $currentIP
            Write-Host "Firewall rule added successfully"
          } else {
            Write-Host "Firewall rule for GitHub Actions already exists"
            
            # Update the rule with current IP
            Write-Host "Updating existing firewall rule with current IP..."
            az sql server firewall-rule update --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name $ruleName --start-ip-address $currentIP --end-ip-address $currentIP
            Write-Host "Firewall rule updated successfully"
          }
          
          # Set IP for cleanup
          echo "GITHUB_ACTIONS_IP=$currentIP" >> $env:GITHUB_ENV
        shell: pwsh
      
      # Execute SQL scripts via Azure CLI
      - name: Deploy SQL Scripts with Azure CLI
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
          SQL_PASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute"
            
            foreach ($script in $scriptFiles) {
              Write-Host "`nExecuting: $($script.Name)"
              
              # Using Azure CLI to execute scripts - this can bypass connection issues
              try {
                # Get script content and truncate for log
                $scriptContent = Get-Content -Path $script.FullName -Raw
                $truncatedContent = if ($scriptContent.Length -gt 200) { $scriptContent.Substring(0, 200) + "..." } else { $scriptContent }
                Write-Host "Script content preview: $truncatedContent"
                
                # Execute script using Azure CLI
                Write-Host "Executing SQL script via Azure CLI..."
                az sql db query --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name ${{ env.SQL_DATABASE_NAME }} --file $script.FullName --query-timeout 30
                
                Write-Host "SQL script execution successful via Azure CLI"
              }
              catch {
                $errorMessage = $_.Exception.Message
                
                if ($errorMessage -match "Violation of PRIMARY KEY constraint" -or 
                    $errorMessage -match "Cannot insert duplicate key") {
                  Write-Host "Duplicate key detected - treating as success"
                } else {
                  Write-Warning "Error executing SQL script: $errorMessage"
                  Write-Host "Continuing despite errors - this is expected if objects already exist"
                }
              }
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
      
      # Clean up temporary firewall rule
      - name: Remove temporary firewall rule
        if: always()
        run: |
          Write-Host "Removing temporary firewall rule..."
          az sql server firewall-rule delete --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --server ${{ env.SQL_SERVER_NAME }} --name "GitHubActions-Temp"
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: deploy-database
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Configure Web.config with Connection String
        run: |
          $zipFile = Get-ChildItem -Path "${{ github.workspace }}" -Filter "*.zip" | Select-Object -First 1
          if ($zipFile) {
            # Extract zip temporarily
            $extractPath = "${{ github.workspace }}\extract"
            Expand-Archive -Path $zipFile.FullName -DestinationPath $extractPath -Force
            
            # Find Web.config
            $webConfigPath = Get-ChildItem -Path $extractPath -Filter "Web.config" -Recurse | Select-Object -First 1 -ExpandProperty FullName
            
            if ($webConfigPath) {
              Write-Host "Found Web.config at: $webConfigPath"
              
              # Read Web.config
              $webConfig = Get-Content -Path $webConfigPath -Raw
              
              # Create new Azure SQL connection string
              $connectionString = "Data Source=${{ env.SQL_SERVER_NAME }}.database.windows.net;Initial Catalog=${{ env.SQL_DATABASE_NAME }};User Id=${{ secrets.AZURE_SQL_USERNAME }};Password=${{ secrets.AZURE_SQL_PASSWORD }};"
              
              # Update the TestConnectionString
              $pattern = 'connectionString="[^"]*" provider'
              $replacement = "connectionString=`"$connectionString`" provider"
              
              # Check if pattern matches
              if ($webConfig -match $pattern) {
                $webConfig = $webConfig -replace $pattern, $replacement
                Write-Host "Updated connection string in Web.config"
              } else {
                Write-Host "Connection string pattern not found, trying alternative pattern..."
                # Alternative pattern that might match
                $altPattern = 'name="TestConnectionString" connectionString="[^"]*"'
                $altReplacement = "name=`"TestConnectionString`" connectionString=`"$connectionString`""
                
                if ($webConfig -match $altPattern) {
                  $webConfig = $webConfig -replace $altPattern, $altReplacement
                  Write-Host "Updated connection string using alternative pattern"
                } else {
                  Write-Warning "Could not find connection string pattern in Web.config"
                  # Print a portion of the Web.config for debugging
                  Write-Host "Web.config excerpt: $($webConfig.Substring(0, [Math]::Min(500, $webConfig.Length)))"
                }
              }
              
              # Update Environment from "Test" to "Production"
              if ($webConfig -match 'key="Environment" value="Test"') {
                $webConfig = $webConfig -replace 'key="Environment" value="Test"', 'key="Environment" value="Production"'
                Write-Host "Updated Environment setting to Production"
              } else {
                Write-Host "Environment setting not found or already set to Production"
              }
              
              # Save the updated Web.config
              Set-Content -Path $webConfigPath -Value $webConfig
              
              # Repackage the zip
              Write-Host "Repackaging updated files..."
              Compress-Archive -Path "$extractPath\*" -DestinationPath "${{ github.workspace }}\updated_site.zip" -Force
              
              # Clean up
              Remove-Item -Path $extractPath -Recurse -Force
              Write-Host "Cleanup completed, site package updated"
            } else {
              Write-Warning "Web.config not found in extracted package"
              Copy-Item -Path $zipFile.FullName -Destination "${{ github.workspace }}\updated_site.zip" -Force
            }
          } else {
            Write-Warning "No ZIP file found for deployment"
          }
        shell: pwsh
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/updated_site.zip
      
      - name: Configure App Service settings
        run: |
          # Set App Service settings
          Write-Host "Configuring App Service settings..."
          
          # Set always-on and HTTP/2
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --always-on true --http20-enabled true
          
          # Set connection string at the App Service level for redundancy
          Write-Host "Setting connection string at App Service level..."
          az webapp config connection-string set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --connection-string-type SQLAzure --settings "TestConnectionString=Data Source=${{ env.SQL_SERVER_NAME }}.database.windows.net;Initial Catalog=${{ env.SQL_DATABASE_NAME }};User Id=${{ secrets.AZURE_SQL_USERNAME }};Password=${{ secrets.AZURE_SQL_PASSWORD }};"
          
          # Configure application settings
          Write-Host "Setting application settings..."
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --settings "Environment=Production" "WEBSITE_NODE_DEFAULT_VERSION=16.13.0"
          
          Write-Host "App Service configuration completed"
        shell: pwsh
      
      - name: Restart Web App
        run: |
          Write-Host "Restarting web app to apply configuration changes..."
          az webapp restart --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging
          
          # Wait for restart to complete
          Write-Host "Waiting for restart to complete..."
          Start-Sleep -Seconds 30
        shell: pwsh
      
      - name: Validate staging deployment
        run: |
          Write-Host "Validating staging deployment..."
          Start-Sleep -Seconds 60
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing -TimeoutSec 30
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Staging deployment validation successful! Status code: $statusCode"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 15
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 15
            }
          }
          
          if (-not $success) {
            # Check app state even if HTTP request fails
            $appState = az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "state" -o tsv
            
            if ($appState -eq "Running") {
              Write-Host "App Service is in 'Running' state despite HTTP validation failure. Proceeding with caution."
            } else {
              Write-Error "Staging deployment validation failed and App Service is not running. State: $appState"
              exit 1
            }
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          Write-Host "Starting slot swap operation from staging to production..."
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
          Write-Host "Slot swap completed successfully"
        shell: pwsh
      
      - name: Configure production App Service settings
        run: |
          # Set App Service settings for production
          Write-Host "Configuring production App Service settings..."
          
          # Set always-on and HTTP/2
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --always-on true --http20-enabled true
          
          # Set connection string at the App Service level for redundancy
          Write-Host "Setting connection string at production App Service level..."
          az webapp config connection-string set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --connection-string-type SQLAzure --settings "TestConnectionString=Data Source=${{ env.SQL_SERVER_NAME }}.database.windows.net;Initial Catalog=${{ env.SQL_DATABASE_NAME }};User Id=${{ secrets.AZURE_SQL_USERNAME }};Password=${{ secrets.AZURE_SQL_PASSWORD }};"
          
          # Configure application settings
          Write-Host "Setting application settings..."
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --settings "Environment=Production" "WEBSITE_NODE_DEFAULT_VERSION=16.13.0"
          
          Write-Host "Production App Service configuration completed"
        shell: pwsh
      
      - name: Restart Production Web App
        run: |
          Write-Host "Restarting production web app to apply configuration changes..."
          az webapp restart --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }}
          
          # Wait for restart to complete
          Write-Host "Waiting for restart to complete..."
          Start-Sleep -Seconds 30
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          Write-Host "Validating production deployment..."
          # Wait longer for production to fully stabilize
          Start-Sleep -Seconds 60
          
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing -TimeoutSec 30
              $statusCode = $response.StatusCode
              
              if ($statusCode -eq 200) {
                Write-Host "Production deployment validation successful! Status code: $statusCode"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $statusCode. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 15
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 15
            }
          }
          
          if (-not $success) {
            # Check app state even if HTTP request fails
            $appState = az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "state" -o tsv
            
            if ($appState -eq "Running") {
              Write-Host "Production App Service is in 'Running' state despite HTTP validation failure."
              Write-Host "Deployment completed with warnings."
            } else {
              Write-Error "Production deployment validation failed and App Service is not running. State: $appState"
              exit 1
            }
          } else {
            Write-Host "🎉 Deployment to production completed successfully! 🎉"
          }
        shell: pwsh
