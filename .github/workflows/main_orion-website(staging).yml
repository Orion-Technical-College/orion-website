name: Build and Deploy Orion Website

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Option 1: If it's a .NET Framework 4.8 application with solution file
      - name: Setup MSBuild (if needed)
        uses: microsoft/setup-msbuild@v1.1
        if: hashFiles('**/*.sln') != ''
      
      - name: Setup NuGet (if needed)
        uses: NuGet/setup-nuget@v1.2.0
        if: hashFiles('**/*.sln') != ''
      
      - name: Restore NuGet packages (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh
      
      - name: Build solution (if needed)
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh
      
      - name: Prepare Web.config for Azure deployment
        run: |
          # Create a temporary copy of Web.config
          Copy-Item -Path "${{ github.workspace }}/Web.config" -Destination "${{ github.workspace }}/Web.config.original" -Force
          
          # Read the Web.config file
          $webConfig = Get-Content -Path "${{ github.workspace }}/Web.config" -Raw
          
          # Add defaultDocument configuration if it doesn't exist
          if ($webConfig -notmatch '<defaultDocument>') {
            $webConfig = $webConfig -replace '<system.webServer>', @"
<system.webServer>
  <defaultDocument>
    <files>
      <clear/>
      <add value="Default.aspx" />
      <add value="default.aspx" />
      <add value="index.html" />
    </files>
  </defaultDocument>
"@
          }
          
          # Update connection string to use Azure SQL
          $azureSqlConnectionString = "Data Source=${{ env.SQL_SERVER_NAME }}.database.windows.net;Initial Catalog=${{ env.SQL_DATABASE_NAME }};User Id=${{ secrets.AZURE_SQL_USERNAME }};Password=${{ secrets.AZURE_SQL_PASSWORD }};"
          $webConfig = $webConfig -replace 'connectionString="[^"]*"', "connectionString=`"$azureSqlConnectionString`""
          
          # Write updated Web.config
          Set-Content -Path "${{ github.workspace }}/Web.config" -Value $webConfig
          
          Write-Host "Web.config prepared for Azure deployment"
        shell: pwsh
      
      # Option 2: If it's just static files or simpler web application
      - name: Package website content
        run: |
          # Create a deployment package for the website
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            # If we didn't build a .NET app above, package directly
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            # Get website files but exclude database scripts, github workflow files, and the published directory itself
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            # Create published directory
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            
            # Create a zip package
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            # Clean up temp directory
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh
      
      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Check for SQL scripts
        id: check-scripts
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            echo "has_scripts=true" >> $env:GITHUB_OUTPUT
          } else {
            echo "has_scripts=false" >> $env:GITHUB_OUTPUT
            Write-Host "No SQL scripts found in Database-Script folder. Skipping database deployment."
          }
        shell: pwsh
      
      - name: Prepare SQL Server PowerShell Module
        if: steps.check-scripts.outputs.has_scripts == 'true'
        run: |
          Write-Host "Preparing SqlServer PowerShell module..."
          # Check if we need to install the module or if we can use existing cmdlets
          if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
            try {
              Install-Module -Name SqlServer -Force -Scope CurrentUser -SkipPublisherCheck -AllowClobber
            } catch {
              Write-Host "Installation failed, but cmdlets may still be available: $_"
            }
          } else {
            Write-Host "Invoke-Sqlcmd is already available. Using existing cmdlets."
          }
          
          # Verify Invoke-Sqlcmd is available
          if (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue) {
            Write-Host "Invoke-Sqlcmd cmdlet is available and ready to use."
          } else {
            Write-Error "Invoke-Sqlcmd cmdlet is not available. SQL script execution will fail."
            exit 1
          }
        shell: pwsh
        
      - name: Deploy SQL Scripts with Direct Replacements
        if: steps.check-scripts.outputs.has_scripts == 'true'
        env:
          SQL_USERNAME: ${{ secrets.AZURE_SQL_USERNAME }}
          SQL_PASSWORD: ${{ secrets.AZURE_SQL_PASSWORD }}
        run: |
          # Get the script files in order
          $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
          
          if ($scriptFiles.Count -gt 0) {
            Write-Host "Found $($scriptFiles.Count) SQL scripts to execute. Running in order..."
            $hasErrors = $false
            
            # Define connection parameters
            $serverName = "${{ env.SQL_SERVER_NAME }}.database.windows.net"
            $databaseName = "${{ env.SQL_DATABASE_NAME }}"
            $connectionString = "Server=$serverName;Database=$databaseName;User ID=$env:SQL_USERNAME;Password=$env:SQL_PASSWORD;Encrypt=True;TrustServerCertificate=False;Connection Timeout=60;"
            
            # Display connection information
            Write-Host "Using server: $serverName"
            Write-Host "Using database: $databaseName"
            Write-Host "Using username: $env:SQL_USERNAME"
            
            foreach ($script in $scriptFiles) {
              Write-Host "Processing: $($script.Name)"
              
              # Read the script content
              $sqlContent = Get-Content -Path "$($script.FullName)" -Raw
              $tempFile = "$($script.FullName).temp"
              
              # Check if script contains SQL variables
              $containsVariables = $sqlContent -match '\$\(SqlDeploymentUser\)' -or $script.Name -eq "Step2-SP.sql" -or $script.Name -eq "Step2-SP-Modified.sql"
              
              if ($containsVariables) {
                Write-Host "Script contains SQL variables - applying direct replacements"
                
                # Create modified content with replacements
                $modifiedContent = $sqlContent
                
                # Replace any variable references
                $modifiedContent = $modifiedContent -replace '\$\(SqlDeploymentUser\)', $env:SQL_USERNAME
                $modifiedContent = $modifiedContent -replace '\$\(CreateDatabaseUser\)', 'true'
                $modifiedContent = $modifiedContent -replace '\$\(CreateDeploymentUserSchema\)', 'true'
                
                # Replace hardcoded user references
                $modifiedContent = $modifiedContent -replace "'nareshki_demo3db'", "'$($env:SQL_USERNAME)'"
                $modifiedContent = $modifiedContent -replace "\[nareshki_demo3db\]", "[$($env:SQL_USERNAME)]"
                $modifiedContent = $modifiedContent -replace "nareshki_demo3db\.", "dbo."
                
                # Write modified content to temp file
                Set-Content -Path $tempFile -Value $modifiedContent
                $fileToExecute = $tempFile
              } else {
                $fileToExecute = $script.FullName
              }
              
              # Execute the script with multiple retries
              $success = $false
              $maxRetries = 3
              $retryCount = 0
              
              while (-not $success -and $retryCount -lt $maxRetries) {
                try {
                  Write-Host "Executing script - Attempt $($retryCount + 1)"
                  Invoke-Sqlcmd -ConnectionString $connectionString -InputFile $fileToExecute -QueryTimeout 300 -ErrorAction Stop
                  $success = $true
                  Write-Host "SQL script executed successfully"
                }
                catch {
                  $retryCount++
                  $errorMessage = $_.Exception.Message
                  
                  # Special handling for duplicate key errors in Step3-Data.sql
                  if ($script.Name -eq "Step3-Data.sql" -and 
                      ($errorMessage -match "Violation of PRIMARY KEY constraint" -or 
                       $errorMessage -match "Cannot insert duplicate key")) {
                    Write-Host "Duplicate key detected in data import script - treating as success"
                    $success = $true
                    Write-Host "Data already exists - continuing deployment"
                  } else {
                    Write-Warning "Execution attempt $retryCount failed: $_"
                    
                    if ($retryCount -lt $maxRetries) {
                      Write-Host "Waiting 10 seconds before retry..."
                      Start-Sleep -Seconds 10
                    }
                    elseif ($containsVariables) {
                      # Last attempt with further modifications
                      try {
                        Write-Host "Making final attempt with additional modifications..."
                        
                        # Comment out problematic sections
                        $lastAttemptContent = $modifiedContent -replace "EXECUTE AS USER\s*=\s*'[^']+'", "-- EXECUTE AS USER commented out by deployment"
                        $lastAttemptContent = $lastAttemptContent -replace "WITH EXECUTE AS\s*=\s*'[^']+'", "-- WITH EXECUTE AS commented out by deployment"
                        $lastAttemptContent = $lastAttemptContent -replace "CREATE USER.*nareshki_demo3db", "-- CREATE USER commented out by deployment"
                        $lastAttemptContent = $lastAttemptContent -replace "CREATE SCHEMA.*nareshki_demo3db", "-- CREATE SCHEMA commented out by deployment"
                        
                        $finalTempFile = "$($script.FullName).final.temp"
                        Set-Content -Path $finalTempFile -Value $lastAttemptContent
                        
                        Invoke-Sqlcmd -ConnectionString $connectionString -InputFile $finalTempFile -QueryTimeout 300 -ErrorAction Stop
                        $success = $true
                        Write-Host "SQL script executed successfully with additional modifications"
                        
                        # Clean up final temp file
                        if (Test-Path $finalTempFile) {
                          Remove-Item $finalTempFile -Force -ErrorAction SilentlyContinue
                        }
                      }
                      catch {
                        Write-Warning "Final attempt failed: $_"
                      }
                    }
                  }
                }
                finally {
                  # Clean up temp file if it exists
                  if ($containsVariables -and (Test-Path $tempFile)) {
                    Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
                  }
                }
              }
              
              if (-not $success) {
                Write-Error "Failed to execute SQL script after all attempts: $($script.Name)"
                $hasErrors = $true
                break
              }
            }
            
            if ($hasErrors) {
              exit 1
            }
          } else {
            Write-Host "No SQL scripts found in Database-Script folder."
          }
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    if: github.event_name != 'pull_request'
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/**/*.zip
      
      - name: Configure Azure Web App Settings
        run: |
          # Enable default document functionality
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --default-documents "Default.aspx,default.aspx,index.html"
          
          # Set runtime configuration settings
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --settings WEBSITE_NODE_DEFAULT_VERSION=10.14.1 ASPNETCORE_ENVIRONMENT=Production SCM_DO_BUILD_DURING_DEPLOYMENT=true
          
          # Disable automatic ASP.NET Core detection (since this is .NET Framework)
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --settings WEBSITE_ASPNET_CORE_DETECTION=0
          
          # Set proper connection string at app setting level for redundancy
          az webapp config connection-string set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --connection-string-type SQLAzure --settings TestConnectionString="Data Source=${{ env.SQL_SERVER_NAME }}.database.windows.net;Initial Catalog=${{ env.SQL_DATABASE_NAME }};User Id=${{ secrets.AZURE_SQL_USERNAME }};Password=${{ secrets.AZURE_SQL_PASSWORD }};"
          
          # Ensure authentication settings are properly configured
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --auth-enabled false
          
          # Enable directory browsing in portal but keep it disabled in web.config
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --auto-heal-enabled true
          
          # Restart the web app to apply all configuration changes
          az webapp restart --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging
          
          # Allow time for restart to complete
          Write-Host "Waiting for application restart to complete..."
          Start-Sleep -Seconds 60
        shell: pwsh
      
      - name: Validate deployment with content verification
        run: |
          # Allow time for application to initialize
          Write-Host "Waiting for application to fully initialize..."
          Start-Sleep -Seconds 60
          
          $maxRetries = 6
          $retryCount = 0
          $success = $false
          $stagingUrl = "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net"
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              Write-Host "Validation attempt $($retryCount + 1) - checking $stagingUrl"
              
              # First check app status via Azure CLI
              $appStatus = az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "state" -o tsv
              Write-Host "App status according to Azure: $appStatus"
              
              # Then check actual HTTP response
              $response = Invoke-WebRequest -Uri $stagingUrl -UseBasicParsing -TimeoutSec 30
              
              if ($response.StatusCode -eq 200) {
                if ($response.Content -notmatch "You do not have permission") {
                  Write-Host "Validation successful - site returned proper content"
                  $success = $true
                } else {
                  Write-Host "Permission error still present in the content. Retrying after app configuration changes take effect..."
                  $retryCount++
                  Start-Sleep -Seconds 20
                }
              } else {
                Write-Host "Unexpected status code: $($response.StatusCode). Retrying..."
                $retryCount++
                Start-Sleep -Seconds 20
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 20
            }
          }
          
          if (-not $success) {
            Write-Error "Deployment validation failed after multiple attempts. Please check application logs in Azure Portal."
            exit 1
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    if: github.event_name != 'pull_request'
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          Write-Host "Swapping staging slot to production..."
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          # Try multiple validation approaches
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          # First try Azure CLI status check
          while ($retryCount -lt 3 -and -not $success) {
            try {
              Write-Host "Validating production deployment using Azure CLI - Attempt $($retryCount + 1)"
              $appStatus = az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "state" -o tsv
              
              if ($appStatus -eq "Running") {
                Write-Host "Azure CLI validation successful! Production app status: $appStatus"
                $success = $true
                break
              } else {
                Write-Host "Production app not in running state. Current status: $appStatus. Retrying..."
                $retryCount++
                Start-Sleep -Seconds 15
              }
            } catch {
              Write-Warning "Azure CLI validation failed: $_"
              $retryCount++
              Start-Sleep -Seconds 15
            }
          }
          
          # If Azure CLI validation succeeded, we can skip HTTP validation
          if ($success) {
            Write-Host "Production deployment validated via Azure CLI. Proceeding to HTTP validation."
          }
          
          # Reset for HTTP validation attempts
          $retryCount = 0
          $success = $false
          
          # Construct the URL correctly
          $productionUrl = "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
          Write-Host "Attempting HTTP validation at: $productionUrl"
          
          # Wait a bit longer before first HTTP attempt
          Write-Host "Waiting 30 seconds for production site to become available..."
          Start-Sleep -Seconds 30
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              Write-Host "Sending HTTP request - Attempt $($retryCount + 1)"
              $response = Invoke-WebRequest -Uri $productionUrl -UseBasicParsing -TimeoutSec 30
              
              if ($response.StatusCode -eq 200) {
                if ($response.Content -notmatch "You do not have permission") {
                  Write-Host "HTTP validation successful! Production returns proper content."
                  $success = $true
                } else {
                  Write-Host "Permission error still present in production. Retrying..."
                  $retryCount++
                  Start-Sleep -Seconds 15
                }
              } else {
                Write-Host "Unexpected status code: $($response.StatusCode). Retrying..."
                $retryCount++
                Start-Sleep -Seconds 15
              }
            } catch {
              $errorMsg = $_.Exception.Message
              Write-Host "HTTP request failed: $errorMsg"
              
              # Handle different error types
              if ($errorMsg -match "No such host is known") {
                Write-Host "DNS resolution issue. The production app might not be deployed yet or hostname is incorrect."
              } elseif ($errorMsg -match "timed out") {
                Write-Host "Request timed out. The production app might be starting up."
              }
              
              $retryCount++
              Start-Sleep -Seconds 15
            }
          }
          
          if (-not $success) {
            Write-Error "Production deployment validation failed after multiple attempts."
            exit 1
          }
        shell: pwsh
