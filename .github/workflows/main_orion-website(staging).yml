name: Deploy Orion Website to Azure

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: 'orion-website'
  AZURE_RESOURCE_GROUP: 'orion-website-rg'
  AZURE_KEYVAULT_NAME: 'orion-website-kv'
  SQL_SERVER_NAME: 'orionweb-sqlserver'
  SQL_DATABASE_NAME: 'OrionWebDB'

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Cache NuGet Packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.config') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1.1

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v1.2.0

      - name: Restore NuGet Packages
        run: |
          if (Test-Path -Path "*.sln") {
            nuget restore *.sln
          }
        shell: pwsh

      - name: Build Solution
        run: |
          if (Test-Path -Path "*.sln") {
            msbuild /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="${{ github.workspace }}\published"
          }
        shell: pwsh

      - name: Package Website
        run: |
          if (-not (Test-Path -Path "${{ github.workspace }}\published\*.zip")) {
            New-Item -Path "${{ github.workspace }}\_temp" -ItemType Directory -Force
            
            Get-ChildItem -Path "${{ github.workspace }}" -Exclude ".git", ".github", "Database-Script", "published", "_temp" | 
              Copy-Item -Destination "${{ github.workspace }}\_temp" -Recurse -Force
            
            New-Item -Path "${{ github.workspace }}\published" -ItemType Directory -Force
            Compress-Archive -Path "${{ github.workspace }}\_temp\*" -DestinationPath "${{ github.workspace }}\published\site.zip" -Force
            
            Remove-Item -Path "${{ github.workspace }}\_temp" -Recurse -Force -ErrorAction SilentlyContinue
          }
        shell: pwsh

      - name: Upload artifact for deployment
        uses: actions/upload-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}\published\**\*.zip

  deploy-database:
    runs-on: windows-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Retrieve SQL credentials from Key Vault
        run: |
          echo "SQL_USERNAME=$(az keyvault secret show --name 'AZURE-SQL-USERNAME' --vault-name ${{ env.AZURE_KEYVAULT_NAME }} --query 'value' -o tsv)" >> $env:GITHUB_ENV
          echo "SQL_PASSWORD=$(az keyvault secret show --name 'AZURE-SQL-PASSWORD' --vault-name ${{ env.AZURE_KEYVAULT_NAME }} --query 'value' -o tsv)" >> $env:GITHUB_ENV
        shell: pwsh
      
      - name: Install SqlServer module
        run: |
          Install-Module -Name SqlServer -Force -Scope CurrentUser -SkipPublisherCheck -AllowClobber
        shell: pwsh
      
      - name: Deploy SQL Scripts
        run: |
          if (Test-Path -Path "${{ github.workspace }}\Database-Script\*.sql") {
            $scriptFiles = Get-ChildItem -Path "${{ github.workspace }}\Database-Script\*.sql" | Sort-Object Name
            
            $serverName = "${{ env.SQL_SERVER_NAME }}.database.windows.net"
            $databaseName = "${{ env.SQL_DATABASE_NAME }}"
            
            foreach ($script in $scriptFiles) {
              Write-Host "Executing: $($script.Name)"
              
              try {
                Invoke-Sqlcmd -ServerInstance $serverName -Database $databaseName -Username $env:SQL_USERNAME -Password $env:SQL_PASSWORD -InputFile "$($script.FullName)" -QueryTimeout 300
                Write-Host "SQL script executed successfully"
              }
              catch {
                if ($_.Exception.Message -match "Violation of PRIMARY KEY constraint" -or 
                    $_.Exception.Message -match "Cannot insert duplicate key") {
                  Write-Host "Duplicate key detected - continuing deployment"
                } else {
                  Write-Warning "Error executing SQL script: $_"
                  exit 1
                }
              }
            }
          } else {
            Write-Host "No SQL scripts found. Skipping database deployment."
          }
        shell: pwsh

  deploy-website:
    runs-on: windows-latest
    needs: [build, deploy-database]
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: website-package
          path: ${{ github.workspace }}
      
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Retrieve connection string from Key Vault
        run: |
          $connectionString = az keyvault secret show --name 'SqlConnectionString' --vault-name ${{ env.AZURE_KEYVAULT_NAME }} --query 'value' -o tsv
          echo "CONNECTION_STRING=$connectionString" >> $env:GITHUB_ENV
        shell: pwsh
      
      - name: Create SqlConnectionString if it doesn't exist
        run: |
          # Check if SqlConnectionString exists in Key Vault
          $exists = az keyvault secret list --vault-name ${{ env.AZURE_KEYVAULT_NAME }} --query "[?name=='SqlConnectionString']" -o tsv
          
          # If it doesn't exist, create it
          if (-not $exists) {
            Write-Host "Creating SqlConnectionString in Key Vault..."
            # Get SQL credentials from Key Vault
            $sqlUsername = az keyvault secret show --name 'AZURE-SQL-USERNAME' --vault-name ${{ env.AZURE_KEYVAULT_NAME }} --query 'value' -o tsv
            $sqlPassword = az keyvault secret show --name 'AZURE-SQL-PASSWORD' --vault-name ${{ env.AZURE_KEYVAULT_NAME }} --query 'value' -o tsv
            
            # Create connection string
            $connectionString = "Data Source=${{ env.SQL_SERVER_NAME }}.database.windows.net;Initial Catalog=${{ env.SQL_DATABASE_NAME }};User ID=$sqlUsername;Password=$sqlPassword;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
            
            # Store in Key Vault
            az keyvault secret set --vault-name ${{ env.AZURE_KEYVAULT_NAME }} --name 'SqlConnectionString' --value "$connectionString"
            
            echo "CONNECTION_STRING=$connectionString" >> $env:GITHUB_ENV
          }
        shell: pwsh
      
      - name: Configure Web.config with Key Vault references
        run: |
          $zipFile = Get-ChildItem -Path "${{ github.workspace }}" -Filter "*.zip" | Select-Object -First 1
          if ($zipFile) {
            # Extract zip temporarily
            $extractPath = "${{ github.workspace }}\extract"
            Expand-Archive -Path $zipFile.FullName -DestinationPath $extractPath -Force
            
            # Find Web.config
            $webConfigPath = Get-ChildItem -Path $extractPath -Filter "Web.config" -Recurse | Select-Object -First 1 -ExpandProperty FullName
            
            if ($webConfigPath) {
              # Update web.config with direct connection string for now
              # We'll later set up the app to use Key Vault references
              $webConfig = Get-Content -Path $webConfigPath -Raw
              
              if ($webConfig -match 'connectionString="[^"]*"') {
                $webConfig = $webConfig -replace 'connectionString="[^"]*"', "connectionString=`"$env:CONNECTION_STRING`""
                Set-Content -Path $webConfigPath -Value $webConfig
                Write-Host "Updated Web.config with connection string"
              }
              
              # Repackage the zip
              Compress-Archive -Path "$extractPath\*" -DestinationPath "${{ github.workspace }}\updated_site.zip" -Force
              
              # Clean up
              Remove-Item -Path $extractPath -Recurse -Force
            }
          }
        shell: pwsh
      
      - name: Deploy to Azure Web App Staging Slot
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ github.workspace }}/updated_site.zip
      
      - name: Configure App Service for Key Vault access
        run: |
          # Enable managed identity
          az webapp identity assign --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
          
          # Get the principal ID of the managed identity
          $principalId = $(az webapp identity show --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query principalId -o tsv)
          
          # Check if this identity already has access to Key Vault
          $hasAccess = az keyvault show --name ${{ env.AZURE_KEYVAULT_NAME }} --query "properties.accessPolicies[?objectId=='$principalId']" -o tsv
          
          if (-not $hasAccess) {
            # Grant Key Vault access
            Write-Host "Granting Key Vault access to App Service managed identity..."
            az keyvault set-policy --name ${{ env.AZURE_KEYVAULT_NAME }} --object-id $principalId --secret-permissions get list
          } else {
            Write-Host "App Service already has access to Key Vault"
          }
          
          # Configure app settings to use Key Vault reference
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --settings "SqlConnectionString=@Microsoft.KeyVault(SecretUri=https://${{ env.AZURE_KEYVAULT_NAME }}.vault.azure.net/secrets/SqlConnectionString/)"
        shell: pwsh
      
      - name: Validate staging deployment
        run: |
          Start-Sleep -Seconds 60
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}-staging.azurewebsites.net" -UseBasicParsing
              if ($response.StatusCode -eq 200) {
                Write-Host "Staging deployment validation successful!"
                $success = $true
              } else {
                Write-Host "Unexpected status code: $($response.StatusCode). Retrying..."
                $retryCount++
                Start-Sleep -Seconds 15
              }
            } catch {
              Write-Host "Request failed: $_. Retrying..."
              $retryCount++
              Start-Sleep -Seconds 15
            }
          }
          
          if (-not $success) {
            $appState = az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "state" -o tsv
            if ($appState -eq "Running") {
              Write-Host "App is running but validation requests failed. Proceeding with caution."
            } else {
              Write-Error "Staging validation failed"
              exit 1
            }
          }
        shell: pwsh

  swap-to-production:
    runs-on: windows-latest
    needs: deploy-website
    environment:
      name: 'production'
      url: 'https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net'
    
    steps:
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Swap staging to production
        run: |
          az webapp deployment slot swap --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --slot staging --target-slot production
        shell: pwsh
      
      - name: Configure production for Key Vault access
        run: |
          # Ensure production slot has managed identity enabled
          az webapp identity assign --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
          
          # Get the principal ID of the managed identity
          $principalId = $(az webapp identity show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query principalId -o tsv)
          
          # Check if this identity already has access to Key Vault
          $hasAccess = az keyvault show --name ${{ env.AZURE_KEYVAULT_NAME }} --query "properties.accessPolicies[?objectId=='$principalId']" -o tsv
          
          if (-not $hasAccess) {
            # Grant Key Vault access
            Write-Host "Granting Key Vault access to production App Service managed identity..."
            az keyvault set-policy --name ${{ env.AZURE_KEYVAULT_NAME }} --object-id $principalId --secret-permissions get list
          } else {
            Write-Host "Production App Service already has access to Key Vault"
          }
          
          # Configure app settings to use Key Vault reference in production
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --settings "SqlConnectionString=@Microsoft.KeyVault(SecretUri=https://${{ env.AZURE_KEYVAULT_NAME }}.vault.azure.net/secrets/SqlConnectionString/)"
        shell: pwsh
      
      - name: Validate production deployment
        run: |
          Start-Sleep -Seconds 60
          $response = Invoke-WebRequest -Uri "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" -UseBasicParsing -MaximumRetryCount 5 -RetryIntervalSec 15
          Write-Host "Production deployment validated - Status code: $($response.StatusCode)"
        shell: pwsh
